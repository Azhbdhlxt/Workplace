C51 COMPILER V9.54   MAIN                                                                  06/14/2023 02:48:56 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Program Files (x86)\keil51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PR
                    -INT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          /*************8*8LED点阵以一行循环滚动显示
   2                        LED点阵旁的J24黄色跳线帽短接到GND一端
   3          *************/
   4          #include <REGX51.H>
   5          
   6          
   7          
   8          
   9          
  10          
  11          typedef unsigned char u8;
  12          typedef unsigned int  u16;
  13          
  14          sbit SRCLK=P3^6;//移位寄存器时钟输入
  15          sbit rCLK=P3^5; //存储寄出去时钟输入
  16          sbit SER=P3^4;  //串行数据输入
  17          
  18          #define LEDDZ_COL_PORT P0//点阵控制端口
  19          
  20          u8 ghc595_buf[8]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};//0000 0001|0000 0010|0000 0100|0000 1000|0001 
             -0000|0010 0000|0100 0000|1000 0000
  21          void delay_10us (u16 ten_us)
  22          {
  23   1              while (ten_us--);
  24   1          
  25   1      }
  26          /*******************************************************************************
  27          * 函 数 名       : delay_ms
  28          * 函数功能               : ms延时函数，ms=1时，大约延时1ms
  29          * 输    入       : ten_us
  30          * 输    出       : 无
  31          *******************************************************************************/
  32          //void delay_ms(u16 ms)
  33          //{
  34          //      u16 i,j;
  35          //      for(i=ms;i>0;i--)
  36          //              for(j=110;j>0;j--);
  37          //}
  38          /*595发送函数*/
  39          /*向74HC595写入一个字节的数据*/
  40          
  41          void hc595_write_data (u8 dat)
  42          {
  43   1              u8 i=0;
  44   1              for(i=0;i<8;i++)                        //循环8次即可将一个字节写入寄存器中
  45   1          {
  46   2                      
  47   2                      SER=dat>>7;                             //优先传输一个字节中的高位
  48   2                      dat<<=1;                                //左移1位，次高位移到最高位
  49   2                      SRCLK=0;
  50   2                      delay_10us(1);                  //时序微秒级，更好兼容芯片
  51   2                      SRCLK=1;
  52   2                      delay_10us(1);//移位寄存器时钟上升沿将端口数据送入寄存器中
  53   2                                  
C51 COMPILER V9.54   MAIN                                                                  06/14/2023 02:48:56 PAGE 2   

  54   2              
  55   2              }
  56   1              rCLK=0;
  57   1              delay_10us(1);
  58   1              rCLK=1;//存储寄存器时钟上升沿将前面写入到寄存器的数据输出
  59   1      }
  60          
  61          
  62          void main()
  63          {
  64   1              u8 i=0;
  65   1              LEDDZ_COL_PORT=0x00;//一开始置低电平  将LED点阵列全部设置为0，即LED阴极为低电平
  66   1           while (1)
  67   1             {
  68   2                              for(i=0;i<8;i++)
  69   2                                      {
  70   3                                              hc595_write_data(0x00);//消影 消除前面寄存器缓存数据
  71   3                                              hc595_write_data (ghc595_buf[i]);//消除前面寄存器缓存数据
  72   3                                              delay_10us (5000);
  73   3                                      }
  74   2             }
  75   1      
  76   1      
  77   1      
  78   1      
  79   1      
  80   1      
  81   1      
  82   1      //}
  83   1      ///**************************************************************************************
  84   1      //深圳市普中科技有限公司（PRECHIN 普中）
  85   1      //技术支持：www.prechin.net
  86   1      //PRECHIN
  87   1      // 普中
  88   1      
  89   1      //实验名称：矩阵按键实验
  90   1      //接线说明：    
  91   1      //实验现象：下载程序后，按下“矩阵按键”模块中S1-S16键，对应数码管最左边显示0-F
  92   1      //注意事项：                                                                                                                                                              
  93   1      //***************************************************************************************/
  94   1      //#include "reg52.h"
  95   1      
  96   1      //typedef unsigned int u16;     //对系统默认数据类型进行重定义
  97   1      //typedef unsigned char u8;
  98   1      
  99   1      //#define KEY_MATRIX_PORT       P1      //使用宏定义矩阵按键控制口              
 100   1      
 101   1      //#define SMG_A_DP_PORT P0      //使用宏定义数码管段码口
 102   1      
 103   1      ////共阴极数码管显示0~F的段码数据
 104   1      //u8 gsmg_code[17]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,
 105   1      //                              0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};       
 106   1      
 107   1      ///*******************************************************************************
 108   1      //* 函 数 名       : delay_10us
 109   1      //* 函数功能             : 延时函数，ten_us=1时，大约延时10us
 110   1      //* 输    入       : ten_us
 111   1      //* 输    出             : 无
 112   1      //*******************************************************************************/
 113   1      //void delay_10us(u16 ten_us)
 114   1      //{
 115   1      //      while(ten_us--);        
C51 COMPILER V9.54   MAIN                                                                  06/14/2023 02:48:56 PAGE 3   

 116   1      //}
 117   1      
 118   1      ///*******************************************************************************
 119   1      //* 函 数 名       : key_matrix_ranks_scan
 120   1      //* 函数功能             : 使用行列式扫描方法，检测矩阵按键是否按下，按下则返回对应键值
 121   1      //* 输    入       : 无
 122   1      //* 输    出             : key_value：1-16，对应S1-S16键，
 123   1      //                                 0：按键未按下
 124   1      //*******************************************************************************/
 125   1      //u8 key_matrix_ranks_scan(void)
 126   1      //{
 127   1      //      u8 key_value=0;
 128   1      
 129   1      //      KEY_MATRIX_PORT=0xf7;//给第一列赋值0，其余全为1
 130   1      //      if(KEY_MATRIX_PORT!=0xf7)//判断第一列按键是否按下
 131   1      //      {
 132   1      //              delay_10us(1000);//消抖
 133   1      //              switch(KEY_MATRIX_PORT)//保存第一列按键按下后的键值     
 134   1      //              {
 135   1      //                      case 0x77: key_value=1;break;
 136   1      //                      case 0xb7: key_value=5;break;
 137   1      //                      case 0xd7: key_value=9;break;
 138   1      //                      case 0xe7: key_value=13;break;
 139   1      //              }
 140   1      //      }
 141   1      //      while(KEY_MATRIX_PORT!=0xf7);//等待按键松开     
 142   1      //      
 143   1      //      KEY_MATRIX_PORT=0xfb;//给第二列赋值0，其余全为1
 144   1      //      if(KEY_MATRIX_PORT!=0xfb)//判断第二列按键是否按下
 145   1      //      {
 146   1      //              delay_10us(1000);//消抖
 147   1      //              switch(KEY_MATRIX_PORT)//保存第二列按键按下后的键值     
 148   1      //              {
 149   1      //                      case 0x7b: key_value=2;break;
 150   1      //                      case 0xbb: key_value=6;break;
 151   1      //                      case 0xdb: key_value=10;break;
 152   1      //                      case 0xeb: key_value=14;break;
 153   1      //              }
 154   1      //      }
 155   1      //      while(KEY_MATRIX_PORT!=0xfb);//等待按键松开     
 156   1      //      
 157   1      //      KEY_MATRIX_PORT=0xfd;//给第三列赋值0，其余全为1
 158   1      //      if(KEY_MATRIX_PORT!=0xfd)//判断第三列按键是否按下
 159   1      //      {
 160   1      //              delay_10us(1000);//消抖
 161   1      //              switch(KEY_MATRIX_PORT)//保存第三列按键按下后的键值     
 162   1      //              {
 163   1      //                      case 0x7d: key_value=3;break;
 164   1      //                      case 0xbd: key_value=7;break;
 165   1      //                      case 0xdd: key_value=11;break;
 166   1      //                      case 0xed: key_value=15;break;
 167   1      //              }
 168   1      //      }
 169   1      //      while(KEY_MATRIX_PORT!=0xfd);//等待按键松开     
 170   1      //      
 171   1      //      KEY_MATRIX_PORT=0xfe;//给第四列赋值0，其余全为1
 172   1      //      if(KEY_MATRIX_PORT!=0xfe)//判断第四列按键是否按下
 173   1      //      {
 174   1      //              delay_10us(1000);//消抖
 175   1      //              switch(KEY_MATRIX_PORT)//保存第四列按键按下后的键值     
 176   1      //              {
 177   1      //                      case 0x7e: key_value=4;break;
C51 COMPILER V9.54   MAIN                                                                  06/14/2023 02:48:56 PAGE 4   

 178   1      //                      case 0xbe: key_value=8;break;
 179   1      //                      case 0xde: key_value=12;break;
 180   1      //                      case 0xee: key_value=16;break;
 181   1      //              }
 182   1      //      }
 183   1      //      while(KEY_MATRIX_PORT!=0xfe);//等待按键松开
 184   1      //      
 185   1      //      return key_value;               
 186   1      //}
 187   1      
 188   1      ///*******************************************************************************
 189   1      //* 函 数 名       : key_matrix_flip_scan
 190   1      //* 函数功能             : 使用线翻转扫描方法，检测矩阵按键是否按下，按下则返回对应键值
 191   1      //* 输    入       : 无
 192   1      //* 输    出             : key_value：1-16，对应S1-S16键，
 193   1      //                                 0：按键未按下
 194   1      //*******************************************************************************/
 195   1      //u8 key_matrix_flip_scan(void)
 196   1      //{
 197   1      //      static u8 key_value=0;
 198   1      
 199   1      //      KEY_MATRIX_PORT=0x0f;//给所有行赋值0，列全为1
 200   1      //      if(KEY_MATRIX_PORT!=0x0f)//判断按键是否按下
 201   1      //      {
 202   1      //              delay_10us(1000);//消抖
 203   1      //              if(KEY_MATRIX_PORT!=0x0f)
 204   1      //              {
 205   1      //                      //测试列
 206   1      //                      KEY_MATRIX_PORT=0x0f;
 207   1      //                      switch(KEY_MATRIX_PORT)//保存行为0，按键按下后的列值    
 208   1      //                      {
 209   1      //                              case 0x07: key_value=1;break;
 210   1      //                              case 0x0b: key_value=2;break;
 211   1      //                              case 0x0d: key_value=3;break;
 212   1      //                              case 0x0e: key_value=4;break;
 213   1      //                      }
 214   1      //                      //测试行
 215   1      //                      KEY_MATRIX_PORT=0xf0;
 216   1      //                      switch(KEY_MATRIX_PORT)//保存列为0，按键按下后的键值    
 217   1      //                      {
 218   1      //                              case 0x70: key_value=key_value;break;
 219   1      //                              case 0xb0: key_value=key_value+4;break;
 220   1      //                              case 0xd0: key_value=key_value+8;break;
 221   1      //                              case 0xe0: key_value=key_value+12;break;
 222   1      //                      }
 223   1      //                      while(KEY_MATRIX_PORT!=0xf0);//等待按键松开     
 224   1      //              }
 225   1      //      }
 226   1      //      else
 227   1      //              key_value=0;            
 228   1      //      
 229   1      //      return key_value;               
 230   1      //}
 231   1      
 232   1      ///*******************************************************************************
 233   1      //* 函 数 名       : main
 234   1      //* 函数功能             : 主函数
 235   1      //* 输    入       : 无
 236   1      //* 输    出             : 无
 237   1      //*******************************************************************************/
 238   1      //void main()
 239   1      //{     
C51 COMPILER V9.54   MAIN                                                                  06/14/2023 02:48:56 PAGE 5   

 240   1      //      u8 key=0;
 241   1      
 242   1      //      while(1)
 243   1      //      {
 244   1      //              key=key_matrix_ranks_scan();
 245   1      //              if(key!=0)
 246   1      //                      SMG_A_DP_PORT=gsmg_code[key-1];//得到的按键值减1换算成数组下标对应0-F段码               
 247   1      //      }               
 248   1      //}
 249   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     88    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
