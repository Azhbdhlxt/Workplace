C51 COMPILER V8.08   MAIN                                                                  02/14/2016 11:11:11 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*********************************************************************************
   2          * 【编写时间】： 2016年02月15日
   3          * 【作    者】： 清翔电子:03
   4          * 【版    本】： 1.0
   5          * 【网    站】： http://www.qxmcu.com/ 
   6          * 【淘宝店铺】： http://qxmcu.taobao.com/ 
   7          * 【实验平台】： QX-MCS51 单片机开发板
   8          * 【外部晶振】： 11.0592mhz     
   9          * 【主控芯片】： STC89C52
  10          * 【编译环境】： Keil μVisio3  
  11          * 【程序功能】： LCD1602液晶循环显示DS1302 31个字节的静态RAM数据                                                                            
  12          * 【使用说明】： 试验前请用杜邦线分别把j5排针根据背面丝印相应接到P10、P11、P12
  13                                           并接上LCD1602液晶调节好对比度再下载此程序
  14                                           【此程序是DS1302工作在突发模式读写31个RAM数据】
  15          
  16          *  说明：免费开源，不提供源代码分析.
  17          **********************************************************************************/
  18          
  19          //调用1602显示驱动，在此文件内已包含51头文件和定义数据类型
  20          #include "LCD1602.h"
  21          /*====================================
  22           IO接口定义
  23          ====================================*/
  24          sbit TSCLK = P1^0; //时钟
  25          sbit TIO = P1^1;   //数据
  26          sbit TRST = P1^2;  //使能
  27          
  28          #define MAIN_Fosc               11059200UL      //宏定义主时钟HZ
  29          #define DS1302_W_ADDR 0xfe  //RAM突发模式寄存器写
  30          #define DS1302_R_ADDR 0xff      //RAM突发模式寄存器读
  31          
  32          //31个字节RAM数据暂存数组
  33          uchar TimeData[31]={0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
  34                                                  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
  35                                                  0x19, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
  36                                                  0x28, 0x29, 0x30, 0x31};
  37          
  38          /*=================================================
  39          *函数名称：Delay_Ms
  40          *函数功能：12T 51单片机自适应主时钟毫秒级延时函数
  41          *说明：需定义MAIN_Fosc（晶振主频单位HZ）
  42          *输入：ms：要延时的毫秒
  43          =================================================*/
  44          void Delay_Ms(INT16U ms)
  45          {
  46   1           INT16U i;
  47   1               do{
  48   2                    i = MAIN_Fosc / 96000; 
  49   2                        while(--i);   //96T per loop
  50   2           }while(--ms);
  51   1      }
  52          /*=================================================
  53          *函数名称：DS1302_W_Byte
  54          *函数功能：DS1302写一字节数据
  55          *输入：dat：要写入的数据
C51 COMPILER V8.08   MAIN                                                                  02/14/2016 11:11:11 PAGE 2   

  56          =================================================*/
  57          void DS1302_W_Byte(uchar dat)
  58          {
  59   1              uchar i;
  60   1              for(i = 0; i < 8; i++) //每次写1bit，写8次
  61   1              {
  62   2                      TSCLK = 0;                 //拉低时钟总线
  63   2                      TIO = dat & 0x01;  //从一字节最低位开始写
  64   2                      TSCLK = 1;                 //拉高时钟总线，DS1302把数据读走
  65   2                      dat >>= 1;                 //数据右移一位 
  66   2              }       
  67   1      }
  68          /*=================================================
  69          *函数名称：DS1302_R_Byte
  70          *函数功能：DS1302读一字节
  71          *输出：dat：读取的数据
  72          =================================================*/
  73          uchar DS1302_R_Byte()
  74          {
  75   1              uchar i, dat;
  76   1              for(i = 0; i < 8; i++)  //每次写1bit，写8次
  77   1              {
  78   2                      TSCLK = 0;                      //拉低时钟总线，DS1302把数据放到数据总线上
  79   2                      dat >>= 1;                      //数据右移一位，数据从最低位开始读 
  80   2                      if(TIO) dat |= 0x80;//读取数据
  81   2                      TSCLK = 1;                      //拉高时钟总线
  82   2              }
  83   1              return dat;                             //返回读取的数据
  84   1      }
  85          /*=================================================
  86          *函数名称：DS1302_W_DAT
  87          *函数功能：写DS1302数据一次写2个字节
  88          *说明：先写命令后写数据
  89          *调用：DS1302_W_Byte()
  90          *输入：cmd：需要写的命令 ，dat：需要些的数据
  91          =================================================*/
  92          void DS1302_W_DAT(uchar cmd, uchar dat)
  93          {
  94   1              TRST = 0;                        //拉低使能端
  95   1              TSCLK = 0;                       //拉低数据总线
  96   1              TRST = 1;                        //拉高使能端，开始写数据
  97   1              DS1302_W_Byte(cmd);      //写命令
  98   1              DS1302_W_Byte(dat);      //写数据
  99   1      }
 100          /*=================================================
 101          *函数名称：DS1302_R_DAT
 102          *函数功能：读DS1302数据
 103          *说明：先写入命令字节后读出对应数据
 104          *调用： DS1302_W_Byte();DS1302_R_Byte();
 105          *输入： cmd：需要写的命令
 106          *输出： dat：读出的数据
 107          =================================================*/
 108          /*uchar DS1302_R_DAT(uchar cmd) //此程序中未使用此函数
 109          {
 110                  uchar dat;
 111                  TRST = 0;                               //拉低使能端
 112                  TSCLK = 0;                              //拉低数据总线
 113                  TRST = 1;                               //拉高使能端，开始写数据
 114                  DS1302_W_Byte(cmd);             //写命令
 115                  dat = DS1302_R_Byte();  //读出数据
 116                  return dat;                             //返回读出数据
 117          }*/
C51 COMPILER V8.08   MAIN                                                                  02/14/2016 11:11:11 PAGE 3   

 118          
 119          /*=================================================
 120          *函数名称：DS1302_Clear_WP
 121          *函数功能：清除DS1302写保护
 122          *说明：先写入命令0x8e（写控制寄存器）接着向该寄存器写0
 123          *调用：DS1302_W_DAT()
 124          =================================================*/
 125          void DS1302_Clear_WP()
 126          {
 127   1              DS1302_W_DAT(0x8e,0x00);  //把控制寄存器WP位置0
 128   1      }
 129          /*=================================================
 130          *函数名称：DS1302_Clear_WP
 131          *函数功能：设置DS1302写保护
 132          *说明：先写入命令0x8e（写控制寄存器）接着向该寄存器写0x80
 133          *调用：DS1302_W_DAT()
 134          =================================================*/
 135          void DS1302_Set_WP()
 136          {       
 137   1              DS1302_W_DAT(0x8e,0x80); //把控制寄存器WP位置1
 138   1              TRST = 0;                                //拉低使能端
 139   1              TSCLK = 0;                               //拉低数据总线
 140   1      } 
 141          /*=================================================
 142          *函数名称：Set_DS1302_Time
 143          *函数功能：写31个字节RAM数据
 144          *说明：把TimeData数据31个字节用突发模式连续写入DS1302
 145                          31个字节静态RAM中
 146          *调用：DS1302_Clear_WP();DS1302_W_Byte();DS1302_Set_WP();
 147          *输入：写RAM突发模式寄存器命令DS1302_W_ADDR
 148          =================================================*/
 149          void Set_DS1302_Time()
 150          {
 151   1              uchar i;
 152   1              DS1302_Clear_WP();              //清除写保护
 153   1              TRST = 0;                               //拉低使能端
 154   1              TSCLK = 0;                              //拉低数据总线
 155   1              TRST = 1;                               //拉高使能端，开始写数据
 156   1              DS1302_W_Byte(DS1302_W_ADDR); //写时钟突发模式寄存器
 157   1              for(i = 0; i < 31; i++) //写31个字节的静态RAM数据
 158   1              {
 159   2              /*      j = TimeData[i]/10;      //BCD码转换
 160   2                      TimeData[i] %= 10;       //BCD码转换
 161   2                      TimeData[i] += j*16; //BCD码转换   */
 162   2                      DS1302_W_Byte(TimeData[i]); //在突发模式下可以连续写数据
 163   2              }
 164   1              DS1302_Set_WP(); //开起写保护           
 165   1      }
 166          /*=================================================
 167          *函数名称：Read_DS1302_Time
 168          *函数功能：读31个字节RAM数据
 169          *说明：用突发模式连续读取DS1302 31个字节的静态RAM数据
 170          *调用：DS1302_Clear_WP();DS1302_R_Byte();DS1302_Set_WP();
 171          *输入：写 读RAM突发模式寄存器命令DS1302_R_ADDR
 172          =================================================*/
 173          void Read_DS1302_Time()
 174          {
 175   1              uchar i;
 176   1              DS1302_Clear_WP();      //清楚些保护
 177   1              TRST = 0;                               //拉低使能端
 178   1              TSCLK = 0;                              //拉低数据总线
 179   1              TRST = 1;                               //拉高使能端，开始写数据
C51 COMPILER V8.08   MAIN                                                                  02/14/2016 11:11:11 PAGE 4   

 180   1              DS1302_W_Byte(DS1302_R_ADDR); //写 读突发模式寄存器命令
 181   1              for(i = 0; i < 31; i++) //读31个字节的静态RAM数据
 182   1              {
 183   2                      TimeData[i] = DS1302_R_Byte();//在突发模式下可以连续读数据
 184   2              }
 185   1              DS1302_Set_WP();   //开起写保护
 186   1      } 
 187          /*=================================================
 188          *函数名称：main
 189          *函数功能：主函数 1602液晶循环显示DS1302RAM数据
 190          =================================================*/
 191          void main()
 192          {
 193   1              InitLcd1602();                  //1602初始化
 194   1              Set_DS1302_Time(); //RAM突发模式写
 195   1              Read_DS1302_Time();//RAM突发模式读
 196   1              while(1)
 197   1              { 
 198   2                      LcdShowStr(2,0,"RAMData(HEX)");  //1602显示字符串 RAM数据（十六进制）
 199   2                      DisplayOneStr (0,1,TimeData[0]); //从第一个数据开始显示
 200   2                      DisplayOneStr (3,1,TimeData[1]);
 201   2                      DisplayOneStr (6,1,TimeData[2]);
 202   2                      DisplayOneStr (9,1,TimeData[3]);
 203   2                      DisplayOneStr (12,1,TimeData[4]);
 204   2                      Delay_Ms(2000);                                  //延时2秒
 205   2                      Lcd1602_Write_Cmd(0x01);    //1602液晶清屏
 206   2                      DisplayOneStr (0,0,TimeData[5]);
 207   2                      DisplayOneStr (3,0,TimeData[6]);
 208   2                      DisplayOneStr (6,0,TimeData[7]);
 209   2                      DisplayOneStr (9,0,TimeData[8]);
 210   2                      DisplayOneStr (12,0,TimeData[9]);
 211   2                      DisplayOneStr (0,1,TimeData[10]);
 212   2                      DisplayOneStr (3,1,TimeData[11]);
 213   2                      DisplayOneStr (6,1,TimeData[12]);
 214   2                      DisplayOneStr (9,1,TimeData[13]);
 215   2                      DisplayOneStr (12,1,TimeData[14]);
 216   2                      Delay_Ms(4000);                                  //延时4秒
 217   2                      Lcd1602_Write_Cmd(0x01);    //1602液晶清屏
 218   2                      DisplayOneStr (0,0,TimeData[15]);
 219   2                      DisplayOneStr (3,0,TimeData[16]);
 220   2                      DisplayOneStr (6,0,TimeData[17]);
 221   2                      DisplayOneStr (9,0,TimeData[18]);
 222   2                      DisplayOneStr (12,0,TimeData[19]);
 223   2                      DisplayOneStr (0,1,TimeData[20]);
 224   2                      DisplayOneStr (3,1,TimeData[21]);
 225   2                      DisplayOneStr (6,1,TimeData[22]);
 226   2                      DisplayOneStr (9,1,TimeData[23]);
 227   2                      DisplayOneStr (12,1,TimeData[24]);
 228   2                      Delay_Ms(4000);                                  //延时4秒
 229   2                      Lcd1602_Write_Cmd(0x01);    //1602液晶清屏
 230   2                      DisplayOneStr (0,0,TimeData[25]);
 231   2                      DisplayOneStr (3,0,TimeData[26]);
 232   2                      DisplayOneStr (6,0,TimeData[27]);
 233   2                      DisplayOneStr (9,0,TimeData[28]);
 234   2                      DisplayOneStr (12,0,TimeData[29]);
 235   2                      DisplayOneStr (0,1,TimeData[30]);
 236   2                      Delay_Ms(5000);                                  //延时5秒
 237   2                      Lcd1602_Write_Cmd(0x01);    //1602液晶清屏
 238   2              }               
 239   1      }


C51 COMPILER V8.08   MAIN                                                                  02/14/2016 11:11:11 PAGE 5   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    509    ----
   CONSTANT SIZE    =     13    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     31    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
